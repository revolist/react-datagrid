{
	"version": 3,
	"sources": [
		"gesture.ts"
	],
	"names": [
		"InteractEvent",
		"ActionName",
		"utils",
		"Gesture",
		"install",
		"scope",
		"actions",
		"Interactable",
		"defaults",
		"prototype",
		"gesturable",
		"options",
		"is",
		"object",
		"gesture",
		"enabled",
		"setPerAction",
		"setOnEvents",
		"bool",
		"names",
		"push",
		"arr",
		"merge",
		"eventTypes",
		"methodDict",
		"updateGestureProps",
		"interaction",
		"iEvent",
		"event",
		"phase",
		"prepared",
		"name",
		"pointers",
		"map",
		"p",
		"pointer",
		"starting",
		"ending",
		"deltaSource",
		"interactable",
		"touches",
		"distance",
		"touchDistance",
		"box",
		"touchBBox",
		"scale",
		"ds",
		"angle",
		"touchAngle",
		"da",
		"startDistance",
		"startAngle",
		"prevEvent",
		"number",
		"Infinity",
		"isNaN",
		"id",
		"before",
		"listeners",
		"arg",
		"length",
		"undefined",
		"gestureOptions",
		"action",
		"getCursor"
	],
	"mappings": "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",
	"sourcesContent": [
		"import InteractEvent from '@interactjs/core/InteractEvent'\nimport { ActionName, Scope } from '@interactjs/core/scope'\nimport * as utils from '@interactjs/utils/index'\n\nexport type GesturableMethod = Interact.ActionMethod<Interact.GesturableOptions>\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    gesture?: {\n      angle: number           // angle from first to second touch\n      distance: number\n      scale: number           // gesture.distance / gesture.startDistance\n      startAngle: number      // angle of line joining two touches\n      startDistance: number   // distance between two touches of touchStart\n    }\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    gesturable: GesturableMethod\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface ActionDefaults {\n    gesture: Interact.GesturableOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Actions {\n    [ActionName.Gesture]?: typeof gesture\n  }\n\n  // eslint-disable-next-line no-shadow\n  enum ActionName {\n    Gesture = 'gesture'\n  }\n}\n\n(ActionName as any).Gesture = 'gesture'\n\nexport interface GestureEvent extends Interact.InteractEvent<ActionName.Gesture> {\n  distance: number\n  angle: number\n  da: number // angle change\n  scale: number // ratio of distance start to current event\n  ds: number // scale change\n  box: Interact.Rect // enclosing box of all points\n  touches: Interact.PointerType[]\n}\n\nexport interface GestureSignalArg extends Interact.DoPhaseArg {\n  iEvent: GestureEvent\n  interaction: Interact.Interaction<ActionName.Gesture>\n  event: Interact.PointerEventType | GestureEvent\n}\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    Interactable,\n    defaults,\n  } = scope\n\n  /**\n   * ```js\n   * interact(element).gesturable({\n   *     onstart: function (event) {},\n   *     onmove : function (event) {},\n   *     onend  : function (event) {},\n   *\n   *     // limit multiple gestures.\n   *     // See the explanation in {@link Interactable.draggable} example\n   *     max: Infinity,\n   *     maxPerElement: 1,\n   * })\n   *\n   * var isGestureable = interact(element).gesturable()\n   * ```\n   *\n   * Gets or sets whether multitouch gestures can be performed on the target\n   *\n   * @param {boolean | object} [options] true/false or An object with event\n   * listeners to be fired on gesture events (makes the Interactable gesturable)\n   * @return {boolean | Interactable} A boolean indicating if this can be the\n   * target of gesture events, or this Interactable\n   */\n  Interactable.prototype.gesturable = function (this: Interact.Interactable, options: Interact.GesturableOptions | boolean) {\n    if (utils.is.object(options)) {\n      this.options.gesture.enabled = options.enabled !== false\n      this.setPerAction(ActionName.Gesture, options)\n      this.setOnEvents(ActionName.Gesture, options)\n\n      return this\n    }\n\n    if (utils.is.bool(options)) {\n      this.options.gesture.enabled = options\n\n      return this\n    }\n\n    return this.options.gesture as Interact.Options\n  } as GesturableMethod\n\n  actions[ActionName.Gesture] = gesture\n  actions.names.push(ActionName.Gesture)\n  utils.arr.merge(actions.eventTypes, [\n    'gesturestart',\n    'gesturemove',\n    'gestureend',\n  ])\n  actions.methodDict.gesture = 'gesturable'\n\n  defaults.actions.gesture = gesture.defaults\n}\n\nfunction updateGestureProps ({ interaction, iEvent, event, phase }: GestureSignalArg) {\n  if (interaction.prepared.name !== 'gesture') { return }\n\n  const pointers = interaction.pointers.map(p => p.pointer)\n  const starting = phase === 'start'\n  const ending = phase === 'end'\n  const deltaSource = interaction.interactable.options.deltaSource\n\n  iEvent.touches = [pointers[0], pointers[1]]\n\n  if (starting) {\n    iEvent.distance = utils.pointer.touchDistance(pointers, deltaSource)\n    iEvent.box      = utils.pointer.touchBBox(pointers)\n    iEvent.scale    = 1\n    iEvent.ds       = 0\n    iEvent.angle    = utils.pointer.touchAngle(pointers, deltaSource)\n    iEvent.da       = 0\n\n    interaction.gesture.startDistance = iEvent.distance\n    interaction.gesture.startAngle = iEvent.angle\n  }\n  else if (ending || event instanceof InteractEvent) {\n    const prevEvent = interaction.prevEvent as GestureEvent\n\n    iEvent.distance = prevEvent.distance\n    iEvent.box      = prevEvent.box\n    iEvent.scale    = prevEvent.scale\n    iEvent.ds       = 0\n    iEvent.angle    = prevEvent.angle\n    iEvent.da       = 0\n  }\n  else {\n    iEvent.distance = utils.pointer.touchDistance(pointers, deltaSource)\n    iEvent.box      = utils.pointer.touchBBox(pointers)\n    iEvent.scale    = iEvent.distance / interaction.gesture.startDistance\n    iEvent.angle    = utils.pointer.touchAngle(pointers, deltaSource)\n\n    iEvent.ds = iEvent.scale - interaction.gesture.scale\n    iEvent.da = iEvent.angle - interaction.gesture.angle\n  }\n\n  interaction.gesture.distance = iEvent.distance\n  interaction.gesture.angle = iEvent.angle\n\n  if (utils.is.number(iEvent.scale) &&\n      iEvent.scale !== Infinity &&\n      !isNaN(iEvent.scale)) {\n    interaction.gesture.scale = iEvent.scale\n  }\n}\n\nconst gesture: Interact.Plugin = {\n  id: 'actions/gesture',\n  before: ['actions/drag', 'actions/resize'],\n  install,\n  listeners: {\n    'interactions:action-start': updateGestureProps,\n    'interactions:action-move': updateGestureProps,\n    'interactions:action-end': updateGestureProps,\n\n    'interactions:new': ({ interaction }) => {\n      interaction.gesture = {\n        angle: 0,\n        distance: 0,\n        scale: 1,\n        startAngle: 0,\n        startDistance: 0,\n      }\n    },\n\n    'auto-start:check': arg => {\n      if (arg.interaction.pointers.length < 2) {\n        return undefined\n      }\n\n      const gestureOptions = arg.interactable.options.gesture\n\n      if (!(gestureOptions && gestureOptions.enabled)) {\n        return undefined\n      }\n\n      arg.action = { name: ActionName.Gesture }\n\n      return false\n    },\n  },\n\n  defaults: {\n  },\n\n  getCursor () {\n    return ''\n  },\n}\n\nexport default gesture\n"
	]
}
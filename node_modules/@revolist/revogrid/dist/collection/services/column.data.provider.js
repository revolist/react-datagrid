import reduce from 'lodash/reduce';
import each from 'lodash/each';
import isArray from 'lodash/isArray';
import map from 'lodash/map';
import DataStore from '../store/dataSource/data.store';
import { columnTypes } from '../store/storeTypes';
export default class ColumnDataProvider {
    constructor(dimensionProvider) {
        this.dimensionProvider = dimensionProvider;
        this.dataSources = reduce(columnTypes, (sources, k) => {
            sources[k] = new DataStore();
            return sources;
        }, {});
    }
    get stores() {
        return this.dataSources;
    }
    column(c, pin) {
        return this.getColumn(c, pin || 'col');
    }
    getColumn(c, type) {
        return this.dataSources[type].store.get('items')[c];
    }
    setColumns(columns) {
        const data = ColumnDataProvider.getColumns(columns);
        each(columnTypes, (k) => {
            this.dataSources[k].updateData(data.columns[k], {
                depth: data.maxLevel,
                groups: reduce(data.columnGrouping[k], (res, g) => {
                    if (!res[g.level]) {
                        res[g.level] = [];
                    }
                    res[g.level].push({
                        name: g.name,
                        ids: g.props
                    });
                    return res;
                }, {})
            });
        });
        this.dimensionProvider.setDimensionSize('col', data.columns.sizes);
        this.dimensionProvider.setRealSize(data.columns.col, 'col');
        for (let p of ['colPinStart', 'colPinEnd']) {
            let pin = p;
            this.dimensionProvider.setPins(data.columns[pin], pin, ColumnDataProvider.getPinSizes(data.columns[pin]));
        }
    }
    static getPinSizes(cols) {
        return reduce(cols, (res, c, i) => {
            if (c.size) {
                res[i] = c.size;
            }
            return res;
        }, {});
    }
    static isColGrouping(colData) {
        return !!colData.children;
    }
    // columns processing
    static getColumns(columns, level = 0) {
        return reduce(columns, (res, colData) => {
            // if grouped column
            if (ColumnDataProvider.isColGrouping(colData)) {
                // receive parsed data up to single cell
                const collection = ColumnDataProvider.getColumns(colData.children, level + 1);
                // group template
                const group = {
                    name: colData.name,
                    level,
                    props: []
                };
                // check columns for update
                for (let k in collection.columns) {
                    const key = k;
                    const resultItem = res.columns[key];
                    const collectionItem = collection.columns[key];
                    // if column data
                    if (isArray(resultItem) && isArray(collectionItem)) {
                        // fill columns
                        resultItem.push(...collectionItem);
                        // fill grouping
                        if (key !== 'sizes' && collectionItem.length) {
                            res.columnGrouping[key].push(Object.assign(Object.assign({}, group), { props: map(collectionItem, 'prop') }));
                        }
                    }
                    else {
                        // fill sizes
                        res.columns[key] = Object.assign(Object.assign({}, resultItem), collectionItem);
                    }
                }
                // merge column groupings
                for (let k in collection.columnGrouping) {
                    const key = k;
                    const collectionItem = collection.columnGrouping[key];
                    res.columnGrouping[key].push(...collectionItem);
                }
                res.maxLevel = Math.max(res.maxLevel, collection.maxLevel);
            }
            else {
                if (!colData.pin) {
                    res.columns.col.push(colData);
                    if (colData.size) {
                        res.columns.sizes[res.columns.col.length - 1] = colData.size;
                    }
                }
                else {
                    res.columns[colData.pin].push(colData);
                }
            }
            return res;
        }, {
            columns: {
                col: [],
                colPinStart: [],
                colPinEnd: [],
                sizes: {}
            },
            columnGrouping: {
                col: [],
                colPinStart: [],
                colPinEnd: []
            },
            maxLevel: level
        });
    }
}

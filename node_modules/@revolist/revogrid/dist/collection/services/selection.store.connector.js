import { createStore } from '@stencil/store';
import { setStore } from '../utils/store.utils';
import { cropCellToMax, getRange, nextCell } from '../store/selection/selection.helpers';
const state = {
    range: null,
    tempRange: null,
    focus: null,
    edit: null,
    lastCell: null
};
export default class SelectionStoreConnector {
    constructor() {
        this.stores = {};
        this.focusedStore = null;
    }
    register(y, x) {
        const store = createStore(Object.assign({}, state));
        if (!this.stores[y]) {
            this.stores[y] = {};
        }
        if (this.stores[y][x]) {
            throw new Error('Store already registered.');
        }
        this.stores[y][x] = store;
        return store;
    }
    focus(store, focus, end) {
        let currentStorePointer;
        // clear all stores focus leave only active one
        for (let y in this.stores) {
            for (let x in this.stores[y]) {
                const s = this.stores[y][x];
                if (s !== store) {
                    this.clearFocus(s);
                }
                else {
                    currentStorePointer = { x: parseInt(x, 10), y: parseInt(y, 10) };
                }
            }
        }
        if (!currentStorePointer) {
            throw new Error('Store not found');
        }
        // check is focus in next store
        const lastCell = store.get('lastCell');
        // item in new store
        const nextItem = nextCell(focus, lastCell);
        let nextStore;
        if (nextItem) {
            for (let i in nextItem) {
                let type = i;
                let stores;
                switch (type) {
                    case 'x':
                        stores = this.getXStores(currentStorePointer.y);
                        break;
                    case 'y':
                        stores = this.getYStores(currentStorePointer.x);
                        break;
                }
                if (nextItem[type] >= 0) {
                    nextStore = stores[++currentStorePointer[type]];
                }
                else {
                    nextStore = stores[--currentStorePointer[type]];
                    const nextLastCell = nextStore === null || nextStore === void 0 ? void 0 : nextStore.get('lastCell');
                    if (nextLastCell) {
                        nextItem[type] = nextLastCell[type] + nextItem[type];
                    }
                }
            }
        }
        // if next store present - update
        if (nextStore) {
            let item = Object.assign(Object.assign({}, focus), nextItem);
            this.focus(nextStore, item, item);
            return;
        }
        focus = cropCellToMax(focus, lastCell);
        end = cropCellToMax(focus, lastCell);
        setStore(store, {
            focus,
            range: getRange(focus, end),
            edit: null,
            tempRange: null
        });
        this.focusedStore = store;
    }
    clearAll() {
        for (let y in this.stores) {
            for (let x in this.stores[y]) {
                this.clearFocus(this.stores[y][x]);
            }
        }
    }
    clearFocus(s) {
        setStore(s, {
            focus: null,
            range: null,
            edit: null,
            tempRange: null
        });
    }
    setRange(store, start, end) {
        const range = getRange(start, end);
        setStore(store, {
            range,
            edit: null,
            tempRange: null
        });
    }
    get edit() {
        var _a;
        return (_a = this.focusedStore) === null || _a === void 0 ? void 0 : _a.get('edit');
    }
    setEdit(val) {
        if (!this.focusedStore) {
            return;
        }
        const focus = this.focused;
        if (focus && typeof val === 'string') { // !dataProvider.isReadOnly(focus.y, focus.x)
            setStore(this.focusedStore, {
                edit: {
                    x: focus.x,
                    y: focus.y,
                    val
                }
            });
            return;
        }
        setStore(this.focusedStore, { edit: null });
    }
    get focused() {
        var _a;
        return (_a = this.focusedStore) === null || _a === void 0 ? void 0 : _a.get('focus');
    }
    change(changes, isMulti = false) {
        if (!this.focusedStore) {
            return;
        }
        const range = this.focusedStore.get('range');
        const focus = this.focusedStore.get('focus');
        if (!range || !focus) {
            return;
        }
        const start = { x: range.x, y: range.y };
        const end = isMulti ? { x: range.x1, y: range.y1 } : start;
        const updateCoordinate = (c) => {
            const point = end[c] > focus[c] ? end : start;
            point[c] += changes[c];
        };
        if (changes.x) {
            updateCoordinate('x');
        }
        if (changes.y) {
            updateCoordinate('y');
        }
        if (isMulti) {
            this.setRange(this.focusedStore, start, end);
        }
        else {
            this.focus(this.focusedStore, start, start);
        }
    }
    unregister(store) {
        for (let y in this.stores) {
            for (let x in this.stores[y]) {
                if (this.stores[y][x] === store) {
                    delete this.stores[y][x];
                    break;
                }
            }
        }
        store.dispose();
    }
    getXStores(y) {
        return this.stores[y];
    }
    getYStores(x) {
        const stores = {};
        for (let i in this.stores) {
            stores[i] = this.stores[i][x];
        }
        return stores;
    }
}
